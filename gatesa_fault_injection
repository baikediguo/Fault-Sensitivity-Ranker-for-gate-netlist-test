import os
import re
import time
import subprocess
from typing import List, Tuple, Set

# ===== é…ç½® =====
ORIGINAL_NETLIST = 'pe.synth_dct.v'
TB_TEMPLATE      = 'tb.v'          # ä½ çš„ testbench æ–‡ä»¶ï¼Œå†…å« DUT å®ä¾‹å uut
CELL_LIB         = 'cells.v'
LOGDIR           = 'sim_logs'
os.makedirs(LOGDIR, exist_ok=True)

STUCK_VALUES     = [0, 1]
SCORE_OUTPUT     = 'sensitive_node_score.txt'

# æ³¨å…¥æ—¶åº
INJECT_DELAY_CYCLES = 5
MAX_VVP_SECONDS     = 60

MAX_UNKNOWN_RATIO   = 0.2

# åŒ¹é… tb æ‰“å°çš„ o_sum åå…­è¿›åˆ¶è¡Œï¼ˆæŒ‰ä½ ç°æœ‰æ ¼å¼ï¼‰
OSUM_HEX_RE = re.compile(r'^o_sum=([0-9a-fA-FxzXZ]+)')

# ----------- å·¥å…·å‡½æ•° -----------

def run_cmd(cmd: List[str], capture=False) -> Tuple[int, str]:
    if capture:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out, _ = proc.communicate()
        return proc.returncode, out
    else:
        rc = subprocess.call(cmd)
        return rc, ''

def strip_comments(text: str) -> str:
    """å»æ‰ // è¡Œæ³¨é‡Š ä¸ /* ... */ å—æ³¨é‡Š"""
    # å»æ‰å—æ³¨é‡Š
    text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)
    # å»æ‰è¡Œæ³¨é‡Š
    text = re.sub(r'//.*', '', text)
    return text

def extract_module(text: str, modname: str) -> str:
    """æŠ½å– module modname ... endmodule çš„æ­£æ–‡ï¼ˆåŒ…å«ç«¯å£ä¸å£°æ˜ï¼‰"""
    m = re.search(rf'\bmodule\s+{re.escape(modname)}\b.*?\bendmodule\b', text, flags=re.DOTALL)
    return m.group(0) if m else ''

def split_decl_names(decl_body: str) -> List[str]:
    """
    å°†è¯¸å¦‚ ' [7:0] a, b , c [3], d ' ä¹‹ç±»çš„å£°æ˜ä½“æ‹†æˆæ ‡è¯†ç¬¦/ä½é€‰æ‹©ã€‚
    ä»…ä¿ç•™å½¢å¦‚ ID æˆ– ID[NUM] çš„å½¢å¼ã€‚
    """
    out = []
    # å»æ‰ä½å®½ [m:n]
    decl_body = re.sub(r'\[[^]\n]*:[^]\n]*\]', '', decl_body)
    # ç”¨é€—å·åˆ†éš”ï¼Œå†å„è‡ª strip
    for chunk in decl_body.split(','):
        token = chunk.strip()
        if not token:
            continue
        # åªä¿ç•™ â€œæ ‡è¯†ç¬¦ + å¯é€‰ [æ•°å­—]â€ è¿™æ ·çš„å½¢å¼
        m = re.match(r'^([A-Za-z_][A-Za-z0-9_$]*)(\[\d+\])?$', token)
        if m:
            out.append(m.group(0))
    return out

def parse_ports(module_text: str) -> Tuple[Set[str], Set[str], Set[str]]:
    """è§£æç«¯å£æ–¹å‘é›†åˆ (inputs, outputs, inouts)"""
    inputs, outputs, inouts = set(), set(), set()
    # æ–¹å‘å£°æ˜å¯èƒ½è·¨è¡Œï¼ŒæŒ‰ ; æ‹†å¥
    for stmt in module_text.split(';'):
        s = stmt.strip()
        if not s:
            continue
        if re.match(r'^\binput\b', s):
            body = re.sub(r'^\binput\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            inputs.update(split_decl_names(body))
        elif re.match(r'^\boutput\b', s):
            body = re.sub(r'^\boutput\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            outputs.update(split_decl_names(body))
        elif re.match(r'^\binout\b', s):
            body = re.sub(r'^\binout\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            inouts.update(split_decl_names(body))
    return inputs, outputs, inouts

def parse_internal_nets(module_text: str) -> Set[str]:
    """è§£æå†…éƒ¨ wire/reg/logic å£°æ˜ï¼ˆä¸åŒ…å«ç«¯å£æ–¹å‘å£°æ˜ï¼‰"""
    nets = set()
    # ä»…åŒ¹é…ç‹¬ç«‹å£°æ˜èµ·å¤´ä¸º wire/reg/logic çš„è¯­å¥
    for stmt in module_text.split(';'):
        s = stmt.strip()
        if not s:
            continue
        if re.match(r'^(wire|reg|logic)\b', s):
            # å»æ‰èµ·å§‹å…³é”®å­—ä¸å¯èƒ½çš„ä¿®é¥°
            body = re.sub(r'^(wire|reg|logic)\b\s+((?:signed|unsigned)\s+)?', '', s)
            nets.update(split_decl_names(body))
    return nets

def parse_targets_from_netlist(netlist_text: str, dut_module: str = 'pe') -> List[str]:
    """
    ç›®æ ‡ï¼šåªæ³¨å…¥ DUT è¾“å‡ºç«¯å£ä¸å†…éƒ¨ netsï¼Œä¸æ³¨å…¥è¾“å…¥ç«¯å£ã€‚
    åŒæ—¶ä¿è¯åå­—æ˜¯åˆæ³•å¯ force çš„å±‚æ¬¡åï¼ˆä¸å«å¥‡æ€ªç¬¦å·ï¼‰ã€‚
    """
    text = strip_comments(netlist_text)
    mod = extract_module(text, dut_module)
    if not mod:
        # å…œåº•ï¼šæ•´ç½‘è¡¨é‡Œåšä¸€æ¬¡æä¿å®ˆè§£æï¼ˆä¸æ¨èï¼Œä½†é¿å…ç©ºé›†åˆï¼‰
        mod = text

    inputs, outputs, _ = parse_ports(mod)
    internals = parse_internal_nets(mod)

    # ç›®æ ‡ = è¾“å‡º âˆª å†…éƒ¨ âˆ’ è¾“å…¥
    targets = (outputs | internals) - inputs

    # æœ€ç»ˆåªä¿ç•™åˆæ³• ID æˆ– ID[NUM]
    good = []
    for n in sorted(targets):
        if re.match(r'^[A-Za-z_][A-Za-z0-9_$]*$', n) or re.match(r'^[A-Za-z_][A-Za-z0-9_$]*\[\d+\]$', n):
            good.append(n)
    return good

# â€”â€” åœ¨ tb ä¸­è¿½åŠ æ³¨å…¥å— â€”â€” #
def make_injected_tb(tb_text: str, target_net: str, stuck: int) -> str:
    inj_block = f"""
// --- fault injection block (auto) ---
initial begin : __fi_block
    // ç­‰å¾…å¤ä½é‡Šæ”¾åï¼Œå†å»¶è¿Ÿè‹¥å¹²å‘¨æœŸæ³¨å…¥
    wait (reset == 0);
    repeat({INJECT_DELAY_CYCLES}) @(posedge clock);
    force uut.{target_net} = 1'b{stuck};
    $display("FAULT_INJECTED: {target_net} sa{stuck}");
end
// --- end injection block ---
"""
    idx = tb_text.rfind('endmodule')
    if idx == -1:
        return tb_text + '\n' + inj_block
    else:
        return tb_text[:idx] + inj_block + tb_text[idx:]

# â€”â€” ç¼–è¯‘ + è¿è¡Œ â€”â€” #
def simulate(tb_file: str, logfile: str) -> bool:
    simv = os.path.join(LOGDIR, 'simv')
    vcd  = os.path.splitext(logfile)[0] + '.vcd'
    compile_cmd = ['iverilog', '-g2012', '-o', simv,
                   os.path.abspath(CELL_LIB),
                   os.path.abspath(ORIGINAL_NETLIST),
                   os.path.abspath(tb_file)]
    rc, out = run_cmd(compile_cmd, capture=True)
    if rc != 0:
        print('âŒ iverilog ç¼–è¯‘å¤±è´¥\n', out)
        return False

    with open(logfile, 'w', encoding='utf-8') as fo:
        proc = subprocess.Popen(['vvp', simv, f'+DUMPFILE={vcd}'],
                                stdout=fo, stderr=subprocess.STDOUT, text=True)
        try:
            proc.wait(timeout=MAX_VVP_SECONDS)
        except subprocess.TimeoutExpired:
            proc.kill()
            print('âŒ vvp ä»¿çœŸè¶…æ—¶')
            return False
    if proc.returncode != 0:
        print(f'âŒ vvp é€€å‡ºç  {proc.returncode}')
        return False
    return True

# â€”â€” è§£æ o_sum æ—¥å¿— â€”â€” #
def parse_osum_as_ints(logfile: str) -> Tuple[List[int], float]:
    vals = []
    total = 0
    unknown = 0
    try:
        with open(logfile, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                m = OSUM_HEX_RE.match(line.strip())
                if not m:
                    continue
                total += 1
                s = m.group(1).lower()
                if 'x' in s or 'z' in s:
                    unknown += 1
                    continue
                try:
                    vals.append(int(s, 16))
                except ValueError:
                    unknown += 1
    except Exception as e:
        print(f'âš ï¸ è¯»å– {logfile} å¤±è´¥: {e}')
    unk_ratio = (unknown / total) if total > 0 else 1.0
    return vals, unk_ratio

def main():
    t0 = time.time()

    print('âš¡ ç”Ÿæˆ golden...')
    golden_log = os.path.join(LOGDIR, 'golden.log')
    if not simulate(TB_TEMPLATE, golden_log):
        print('âŒ Golden å¤±è´¥ï¼Œé€€å‡º')
        return
    golden_vals, golden_unk = parse_osum_as_ints(golden_log)
    if not golden_vals:
        print('âŒ golden.log æ²¡æœ‰æœ‰æ•ˆçš„ o_sum æ ·æœ¬')
        return
    print(f'âœ… golden æ ·æœ¬æ•°={len(golden_vals)}, unknown æ¯”ä¾‹={golden_unk:.2%}')

    with open(ORIGINAL_NETLIST, 'r', encoding='utf-8', errors='ignore') as f:
        net_text = f.read()
    targets = parse_targets_from_netlist(net_text, dut_module='pe')
    print(f'ğŸ¯ æ³¨å…¥ç›®æ ‡ï¼ˆè¾“å‡ºç«¯å£ âˆª å†…éƒ¨ netsï¼Œæ’é™¤è¾“å…¥ï¼‰ï¼šå…± {len(targets)} ä¸ªï¼Œä¾‹å¦‚: {targets[:8]}')

    with open(TB_TEMPLATE, 'r', encoding='utf-8', errors='ignore') as f:
        tb_src = f.read()

    node_scores = {}
    total_runs = 0

    for i, net in enumerate(targets, 1):
        total_diff = 0
        valid_any = False
        for val in STUCK_VALUES:
            tb_inj = make_injected_tb(tb_src, net, val)
            tmp_tb = os.path.join(LOGDIR, 'tb_inj.v')
            with open(tmp_tb, 'w', encoding='utf-8') as w:
                w.write(tb_inj)
            log = os.path.join(LOGDIR, f'fi_{re.sub(r"[^A-Za-z0-9_$\[\]]", "_", net)}_sa{val}.log')

            ok = simulate(tmp_tb, log)
            os.remove(tmp_tb)
            if not ok:
                continue

            vals, unk = parse_osum_as_ints(log)
            if not vals or unk > MAX_UNKNOWN_RATIO:
                continue

            L = min(len(golden_vals), len(vals))
            diff = sum(1 for a, b in zip(golden_vals[:L], vals[:L]) if a != b)
            total_diff += diff
            valid_any = True
            total_runs += 1

        node_scores[net] = total_diff if valid_any else 0

        if i % 50 == 0:
            print(f'è¿›åº¦ {i}/{len(targets)} â€” æœ€è¿‘èŠ‚ç‚¹åˆ†æ•°={node_scores[net]}')

    with open(SCORE_OUTPUT, 'w', encoding='utf-8') as f:
        for n, s in node_scores.items():
            f.write(f'{n} {s}\n')

    elapsed = time.time() - t0
    nonzero = sum(1 for s in node_scores.values() if s > 0)
    print('â€”â€” ç»Ÿè®¡ â€”â€”')
    print(f'å·²æ³¨å…¥ç›®æ ‡æ•°: {len(targets)}')
    print(f'æœ‰æ•ˆä»¿çœŸæ¬¡æ•°: {total_runs}')
    print(f'éé›¶åˆ†èŠ‚ç‚¹æ•°: {nonzero} ({(nonzero/len(targets) if targets else 0):.2%})')
    print(f'è¾“å‡º: {SCORE_OUTPUT}')
    print(f'â±ï¸ æ€»è€—æ—¶: {elapsed:.2f}s')

if __name__ == '__main__':
    main()
