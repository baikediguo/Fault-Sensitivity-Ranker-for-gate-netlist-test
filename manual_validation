# manual_validation.py
import os
import re
import time
import subprocess
from typing import List, Tuple, Set

# ===== åŸºæœ¬é…ç½®ï¼ˆæŒ‰ä½ çš„é¡¹ç›®å‘½åï¼‰=====
VERILOG_SRC = 'pe.synth_dct.v'    # ç½‘è¡¨
TB_FILE     = 'tb.v'              # testbenchï¼Œå†…å«å®ä¾‹å uutã€ä¿¡å· clock/resetã€$display("o_sum=...") æ‰“å°
CELL_LIB    = 'cells.v'           # å·¥è‰ºåº“ï¼ˆåŠ¡å¿…å­˜åœ¨ï¼‰
RANK_FILE   = 'gnn_rank.txt'      # GNN é¢„æµ‹ç»“æœï¼ˆæ¯è¡Œï¼šèŠ‚ç‚¹å åˆ†æ•°ï¼‰

# æ—¥å¿—&ä¸´æ—¶æ–‡ä»¶ç›®å½•
LOGDIR = 'sim_logs_manual'
os.makedirs(LOGDIR, exist_ok=True)

# é€‰æ‹©å‰ K ä¸ªèŠ‚ç‚¹éªŒè¯
TOPK = 1025

# æ³¨å…¥æ—¶åºï¼šç­‰å¾… reset é‡Šæ”¾ï¼Œå†å»¶è¿Ÿè‹¥å¹²å‘¨æœŸ
INJECT_DELAY_CYCLES = 5
MAX_VVP_SECONDS     = 60

# è¾“å‡ºè¡ŒåŒ¹é…ï¼ˆä¸ä½ çš„ tb æ‰“å°ä¸€è‡´ï¼‰
OSUM_HEX_RE = re.compile(r'^o_sum=([0-9a-fA-FxzXZ]+)')

# å…è®¸çš„æœªçŸ¥æ¯”ä¾‹ï¼ˆä»¿çœŸé‡Œå« X/Z å¤ªå¤šçš„ç»“æœç®—æ— æ•ˆï¼‰
MAX_UNKNOWN_RATIO = 0.2


# ---------- å­ç¨‹åº ----------

def run_cmd(cmd: List[str], capture=False, timeout=None) -> Tuple[int, str]:
    """
    æ‰§è¡Œå‘½ä»¤ï¼›åœ¨ Windows ä¸‹ç”¨ UTF-8 å¹¶å¿½ç•¥ä¸èƒ½è§£ç çš„å­—ç¬¦ï¼Œé¿å… gbk æŠ¥é”™ã€‚
    """
    if capture:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                                text=True, encoding='utf-8', errors='ignore')
        try:
            out, _ = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            return -1, 'TIMEOUT'
        return proc.returncode, out
    else:
        try:
            rc = subprocess.call(cmd)
            return rc, ''
        except Exception as e:
            return -1, str(e)


def strip_comments(text: str) -> str:
    text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)
    text = re.sub(r'//.*', '', text)
    return text


def extract_module(text: str, modname: str) -> str:
    m = re.search(rf'\bmodule\s+{re.escape(modname)}\b.*?\bendmodule\b', text, flags=re.DOTALL)
    return m.group(0) if m else ''


def split_decl_names(decl_body: str) -> List[str]:
    out = []
    decl_body = re.sub(r'\[[^]\n]*:[^]\n]*\]', '', decl_body)
    for chunk in decl_body.split(','):
        token = chunk.strip()
        if not token:
            continue
        m = re.match(r'^([A-Za-z_][A-Za-z0-9_$]*)(\[\d+\])?$', token)
        if m:
            out.append(m.group(0))
    return out


def parse_ports(module_text: str) -> Tuple[Set[str], Set[str], Set[str]]:
    inputs, outputs, inouts = set(), set(), set()
    for stmt in module_text.split(';'):
        s = stmt.strip()
        if not s: continue
        if re.match(r'^\binput\b', s):
            body = re.sub(r'^\binput\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            inputs.update(split_decl_names(body))
        elif re.match(r'^\boutput\b', s):
            body = re.sub(r'^\boutput\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            outputs.update(split_decl_names(body))
        elif re.match(r'^\binout\b', s):
            body = re.sub(r'^\binout\b\s+((?:wire|reg|logic|signed|unsigned)\s+)*', '', s)
            inouts.update(split_decl_names(body))
    return inputs, outputs, inouts


def parse_internal_nets(module_text: str) -> Set[str]:
    nets = set()
    for stmt in module_text.split(';'):
        s = stmt.strip()
        if not s: continue
        if re.match(r'^(wire|reg|logic)\b', s):
            body = re.sub(r'^(wire|reg|logic)\b\s+((?:signed|unsigned)\s+)?', '', s)
            nets.update(split_decl_names(body))
    return nets


def parse_targets_from_netlist(netlist_text: str, dut_module: str = 'pe') -> List[str]:
    """
    æ³¨å…¥é›†åˆï¼šè¾“å‡ºç«¯å£ âˆª å†…éƒ¨ nets âˆ’ è¾“å…¥ç«¯å£ï¼›ä»…ä¿ç•™å¯ force çš„åˆæ³•åå­—ï¼ˆID æˆ– ID[NUM]ï¼‰
    """
    text = strip_comments(netlist_text)
    mod = extract_module(text, dut_module)
    if not mod:
        mod = text
    inputs, outputs, _ = parse_ports(mod)
    internals = parse_internal_nets(mod)
    targets = (outputs | internals) - inputs

    good = []
    for n in sorted(targets):
        if re.match(r'^[A-Za-z_][A-Za-z0-9_$]*$', n) or re.match(r'^[A-Za-z_][A-Za-z0-9_$]*\[\d+\]$', n):
            good.append(n)
    return good


def make_injected_tb(tb_text: str, target_net: str, stuck: int) -> str:
    inj_block = f"""
// --- fault injection block (auto) ---
initial begin : __fi_block
    wait (reset == 0);
    repeat({INJECT_DELAY_CYCLES}) @(posedge clock);
    force uut.{target_net} = 1'b{stuck};
    $display("FAULT_INJECTED: {target_net} sa{stuck}");
end
// --- end injection block ---
"""
    idx = tb_text.rfind('endmodule')
    if idx == -1:
        return tb_text + '\n' + inj_block
    else:
        return tb_text[:idx] + inj_block + tb_text[idx:]


def compile_and_run(sources: List[str], exe_path: str, vcd_path: str, log_path: str,
                    timeout: int = MAX_VVP_SECONDS) -> bool:
    """
    Icarus æµç¨‹ï¼šiverilog -g2012 (cells, netlist, tb) + vvp +DUMPFILE
    æ—¥å¿—ç»Ÿä¸€å†™å…¥ log_pathï¼›è¿”å› True/False
    """
    # å…ˆç¼–è¯‘
    cmd_compile = ['iverilog', '-g2012', '-o', exe_path] + [os.path.abspath(s) for s in sources]
    rc, out = run_cmd(cmd_compile, capture=True)
    if rc != 0:
        with open(log_path, 'w', encoding='utf-8', errors='ignore') as f:
            f.write(out)
        return False

    # å†è¿è¡Œ
    cmd_run = ['vvp', exe_path, f'+DUMPFILE={vcd_path}']
    with open(log_path, 'w', encoding='utf-8', errors='ignore') as f:
        try:
            proc = subprocess.Popen(cmd_run, stdout=f, stderr=subprocess.STDOUT,
                                    text=True, encoding='utf-8', errors='ignore')
            proc.wait(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            f.write('\n[ERROR] vvp TIMEOUT\n')
            return False

    return True


def parse_osum_as_ints(logfile: str) -> Tuple[List[int], float]:
    vals, total, unknown = [], 0, 0
    try:
        with open(logfile, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                m = OSUM_HEX_RE.match(line.strip())
                if not m:
                    continue
                total += 1
                s = m.group(1).lower()
                if 'x' in s or 'z' in s:
                    unknown += 1
                    continue
                try:
                    vals.append(int(s, 16))
                except ValueError:
                    unknown += 1
    except Exception as e:
        print(f'âš ï¸ è¯»å– {logfile} å¤±è´¥: {e}')
    unk_ratio = (unknown / total) if total > 0 else 1.0
    return vals, unk_ratio


def load_gnn_topk(path: str, topk: int) -> List[str]:
    if not os.path.exists(path):
        print(f'âŒ æœªæ‰¾åˆ° {path}')
        return []
    nodes = []
    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            line = line.strip()
            if not line: continue
            parts = line.split()
            if len(parts) >= 1:
                nodes.append(parts[0])
    return nodes[:topk]


# ---------- ä¸»æµç¨‹ ----------

def main():
    t0 = time.time()
    print('=== manual_validation.py starting ===')

    # 1) ç”Ÿæˆ golden
    print('è¿è¡Œ golden ä»¿çœŸï¼ˆåŸºå‡†ï¼‰...')
    golden_exe = os.path.join(LOGDIR, 'golden.out')
    golden_vcd = os.path.join(LOGDIR, 'golden.vcd')
    golden_log = os.path.join(LOGDIR, 'golden.log')
    ok = compile_and_run([CELL_LIB, VERILOG_SRC, TB_FILE], golden_exe, golden_vcd, golden_log,
                         timeout=MAX_VVP_SECONDS)
    if not ok:
        print('âŒ Golden ä»¿çœŸå¤±è´¥')
        with open(golden_log, 'r', encoding='utf-8', errors='ignore') as f:
            print(f.read())
        return
    golden_vals, golden_unk = parse_osum_as_ints(golden_log)
    if not golden_vals:
        print('âŒ golden.log æ²¡æœ‰æœ‰æ•ˆçš„ o_sum æ ·æœ¬')
        return
    print(f'âœ… golden æ ·æœ¬ {len(golden_vals)}ï¼Œunknown_ratio={golden_unk:.2%}')

    # 2) è§£æå¯æ³¨å…¥çš„åˆæ³•ç›®æ ‡ï¼ˆä»ç½‘è¡¨ï¼‰
    with open(VERILOG_SRC, 'r', encoding='utf-8', errors='ignore') as f:
        net_text = f.read()
    legal_targets = set(parse_targets_from_netlist(net_text, dut_module='pe'))

    # 3) è¯»å– GNN æ’åå‰ Kï¼Œå¹¶ä¸åˆæ³•ç›®æ ‡æ±‚äº¤é›†
    gnn_topk = load_gnn_topk(RANK_FILE, TOPK)
    filtered_topk = [n for n in gnn_topk if n in legal_targets
                     and not re.match(r'^(clk|clock|rst|reset|in)', n, flags=re.IGNORECASE)]
    if not filtered_topk:
        print('âŒ GNN å‰ K ä¸å¯æ³¨å…¥ç›®æ ‡æ— äº¤é›†')
        return

    print(f'ğŸ¯ éªŒè¯èŠ‚ç‚¹æ•°: {len(filtered_topk)}ï¼ˆç¤ºä¾‹å‰20ï¼‰: {filtered_topk[:20]}')

    # 4) éå†æ¯ä¸ªèŠ‚ç‚¹ï¼Œåˆ†åˆ«æ³¨å…¥ sa0/sa1ï¼Œä»»ä¸€é€ æˆè¾“å‡ºå·®å¼‚å³è®°ä¸ºâ€œæ£€æµ‹åˆ°â€
    detected_nodes = 0
    per_fault_detect = 0   # å¯é€‰ï¼šç»Ÿè®¡ (node, saX) ç²’åº¦
    total_faults = len(filtered_topk) * 2

    with open(TB_FILE, 'r', encoding='utf-8', errors='ignore') as f:
        tb_src = f.read()

    for i, net in enumerate(filtered_topk, 1):
        node_detected = False
        for val in [0, 1]:
            tb_inj = make_injected_tb(tb_src, net, val)
            tb_tmp = os.path.join(LOGDIR, f'tb_inj_{i}_sa{val}.v')
            with open(tb_tmp, 'w', encoding='utf-8', errors='ignore') as w:
                w.write(tb_inj)

            exe = os.path.join(LOGDIR, f'sim_{i}_sa{val}.out')
            vcd = os.path.join(LOGDIR, f'sim_{i}_sa{val}.vcd')
            log = os.path.join(LOGDIR, f'sim_{i}_sa{val}.log')

            ok = compile_and_run([CELL_LIB, VERILOG_SRC, tb_tmp], exe, vcd, log, timeout=MAX_VVP_SECONDS)
            if not ok:
                # ç¼–è¯‘/ä»¿çœŸå¤±è´¥ï¼Œè®¤ä¸ºæœ¬ fault æœªæ£€æµ‹ï¼›ç»§ç»­ä¸‹ä¸€ä¸ª
                continue

            vals, unk = parse_osum_as_ints(log)
            if not vals or unk > MAX_UNKNOWN_RATIO:
                # è¾“å‡ºæ— æ•ˆï¼ˆX/Z å¤ªå¤šæˆ–æ²¡é‡‡æ ·ï¼‰ï¼Œè®°ä¸ºæœªæ£€æµ‹è¯¥ fault
                continue

            L = min(len(golden_vals), len(vals))
            diff = sum(1 for a, b in zip(golden_vals[:L], vals[:L]) if a != b)
            if diff > 0:
                node_detected = True
                per_fault_detect += 1

        if node_detected:
            detected_nodes += 1

        if i % 20 == 0 or i == len(filtered_topk):
            print(f'è¿›åº¦ {i}/{len(filtered_topk)} â€” èŠ‚ç‚¹ç´¯è®¡æ£€æµ‹={detected_nodes}/{i}ï¼Œ'
                  f'faultç´¯è®¡æ£€æµ‹={per_fault_detect}/{i*2}')

    # 5) ç»Ÿè®¡
    node_cov = detected_nodes / len(filtered_topk) * 100.0
    fault_cov = per_fault_detect / total_faults * 100.0

    print('\nâ€”â€” ç»Ÿè®¡ â€”â€”')
    print(f'èŠ‚ç‚¹æ€»æ•°(éªŒè¯): {len(filtered_topk)}')
    print(f'æ£€æµ‹åˆ°çš„èŠ‚ç‚¹æ•°: {detected_nodes}')
    print(f'èŠ‚ç‚¹è¦†ç›–ç‡:     {node_cov:.2f}%')
    print(f'æ•…éšœæ€»æ•°(èŠ‚ç‚¹*2): {total_faults}')
    print(f'æ£€æµ‹åˆ°çš„æ•…éšœæ•°: {per_fault_detect}')
    print(f'æ•…éšœè¦†ç›–ç‡:     {fault_cov:.2f}%')
    print(f'â± æ€»è€—æ—¶: {time.time() - t0:.1f}s')


if __name__ == '__main__':
    main()
